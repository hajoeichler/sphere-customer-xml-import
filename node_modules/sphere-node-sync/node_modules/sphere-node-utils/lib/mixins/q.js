var Q, _;

Q = require('q');

_ = require('underscore');


/**
 * Collection of Q utils
 */

module.exports = {

  /**
   * Process each element in the given list using the function fn (called on each iteration).
   * The function fn has to return a promise that should be resolved when all elements of the page are processed.
   * @param {Array} list A list of elements to process
   * @param {Function} fn The function to process a page that returns a promise
   * @param {Object} [options] Optional parameters to configure the process
   * - `maxParallel` (default 1) defines how many elements from the list will be passed to the process function
   * - `accumulate` (default true) whether to accumulate or not all results to be returned at the end
   * @throws {Error} If arguments are not correct
   * @return {Promise} A promise, fulfilled with an array of the resolved results of function fn or the rejected result of fn
   * @example
   *   list = [{key: '1'}, {key: '2'}, {key: '3'}]
   *   processList list, (elems) ->
   *     doSomethingWith(elems) # it's a promise
   *     .then ->
   *       # something else
   *       anotherPromise().then -> Q('OK')
   *   .then (results) -> # results will be an array ['OK', 'OK', 'OK']
   */
  processList: function(list, fn, options) {
    var acc, accumulate, d, maxParallel, _process, _ref;
    if (options == null) {
      options = {};
    }
    if (!_.isFunction(fn)) {
      throw new Error('Please provide a function to process the list');
    }
    d = Q.defer();
    _ref = _.defaults(options, {
      maxParallel: 1,
      accumulate: true
    }), maxParallel = _ref.maxParallel, accumulate = _ref.accumulate;
    if (maxParallel < 1) {
      throw new Error('MaxParallel must be a number >= 1');
    }
    acc = [];
    _process = function(tickList) {
      var elements, tail;
      if (_.isEmpty(tickList)) {
        return d.resolve(acc);
      } else {
        elements = _.head(tickList, maxParallel);
        tail = _.tail(tickList, maxParallel);
        return fn(elements).then(function(result) {
          if (accumulate) {
            acc.push(result);
          }
          return _process(tail);
        }).fail(function(error) {
          return d.reject(error);
        }).done();
      }
    };
    _process(list);
    return d.promise;
  }
};
