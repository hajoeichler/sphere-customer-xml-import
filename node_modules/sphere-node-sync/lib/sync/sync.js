var Logger, Q, SphereClient, Sync, Utils, _;

_ = require('underscore');

Q = require('q');

SphereClient = require('sphere-node-client');

Logger = require('../logger');

Utils = require('../utils/utils');


/*
Base Sync class
 */

Sync = (function() {
  function Sync(opts) {
    if (opts == null) {
      opts = {};
    }
    this._logger = new Logger(opts.logConfig);
    if (!_.isEmpty(opts)) {
      this._client = new SphereClient(_.extend(opts, {
        logConfig: {
          logger: this._logger
        }
      }));
    }
    this._logger.debug(opts, "New " + this.constructor.name + " object");
    this._data = {};
    this._utils = new Utils;
    this._syncConfig = [];
  }

  Sync.prototype.config = function(opts) {
    this._syncConfig = opts || [];
    return this;
  };

  Sync.prototype.buildActions = function(new_obj, old_obj) {
    var actions, diff, update;
    diff = this._utils.diff(old_obj, new_obj);
    this._logger.debug(diff, "JSON diff for " + this.constructor.name + " object");
    update = void 0;
    if (diff) {
      actions = this._doMapActions(diff, new_obj, old_obj);
      if (actions.length > 0) {
        update = {
          actions: actions,
          version: old_obj.version
        };
      }
    }
    this._data = {
      update: update,
      updateId: old_obj.id
    };
    this._logger.debug(this._data, "Data update for " + this.constructor.name + " object");
    return this;
  };

  Sync.prototype.filterActions = function(fn) {
    var filtered;
    if (!fn) {
      return this;
    }
    if (!this._data.update) {
      return this;
    }
    filtered = _.filter(this._data.update.actions, fn);
    if (_.isEmpty(filtered)) {
      this._data.update = void 0;
    } else {
      this._data.update.actions = filtered;
    }
    return this;
  };

  Sync.prototype.get = function(key) {
    if (key == null) {
      key = 'update';
    }
    return this._data[key];
  };

  Sync.prototype.update = function() {
    if (!this._client) {
      throw new Error('Cannot update: the Rest connector wasn\'t instantiated (probabily because of missing credentials)');
    }
    if (!_.isEmpty(this._data.update)) {
      return this._doUpdate();
    } else {
      return Q({
        statusCode: 304,
        body: null
      });
    }
  };

  Sync.prototype._mapActionOrNot = function(type, fn) {
    var found;
    if (_.isEmpty(this._syncConfig)) {
      return fn();
    }
    found = _.find(this._syncConfig, function(c) {
      return c.type === type;
    });
    if (!found) {
      return [];
    }
    switch (found.group) {
      case 'black':
        return [];
      case 'white':
        return fn();
      default:
        throw new Error("Action group '" + found.group + "' not supported. Please use black or white.");
    }
  };


  /*
  Methods to override
   */

  Sync.prototype._doMapActions = function(diff, new_obj, old_obj) {
    return [];
  };

  Sync.prototype._doUpdate = function() {
    return Q();
  };

  return Sync;

})();


/*
Exports object
 */

module.exports = Sync;
