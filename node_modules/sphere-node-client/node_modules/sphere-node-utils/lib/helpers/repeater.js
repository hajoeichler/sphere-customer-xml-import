var Q, Repeater, _;

Q = require('q');

_ = require('underscore');


/**
 * Repeater is designed to repeat some arbitrary function unless the execution of this function does not throw any errors
 *
 * Options:
 *   attempts - Int - how many times execution of the function should be repeated until repeater will give up (default 10)
 *   timeout - Long - the delay between attempts
 *   timeoutType - String - The type of the timeout:
 *     'constant' - always the same timeout
 *     'variable' - timeout grows with the attempts count (it also contains random component)
 */

Repeater = (function() {
  function Repeater(options) {
    if (options == null) {
      options = {};
    }
    this._attempts = options.attempts != null ? options.attempts : 10;
    this._timeout = options.timeout != null ? options.timeout : 100;
    this._timeoutType = options.timeoutType || 'variable';
  }


  /**
   * Executes arbitrary function
   *
   * Options:
   *   task - () => Promise[Any] - the task that should be executed
   *   recoverableError - Error => Boolean - function that decides, whether an error can be recovered by repeating the task execution
   */

  Repeater.prototype.execute = function(options) {
    var d;
    if (!_.isFunction(options.task)) {
      throw new Error('`task` function is undefined');
    }
    if (!_.isFunction(options.recoverableError)) {
      throw new Error('`recoverableError` function is undefined');
    }
    d = Q.defer();
    this._repeat(this._attempts, options, d, null);
    return d.promise;
  };

  Repeater.prototype._repeat = function(remainingAttempts, options, defer, lastError) {
    var recoverableError, task;
    task = options.task, recoverableError = options.recoverableError;
    if (remainingAttempts === 0) {
      return defer.reject(new Error("Unsuccessful after " + this._attempts + " attempts. Cause: " + lastError.stack));
    } else {
      return task().then(function(res) {
        return defer.resolve(res);
      }).fail((function(_this) {
        return function(e) {
          if (recoverableError(e)) {
            return Q.delay(_this._calculateDelay(remainingAttempts)).then(function(i) {
              return _this._repeat(remainingAttempts - 1, options, defer, e);
            });
          } else {
            return defer.reject(e);
          }
        };
      })(this)).done();
    }
  };

  Repeater.prototype._calculateDelay = function(attemptsLeft) {
    var tried;
    if (this._timeoutType === 'constant') {
      return this._timeout;
    } else if (this._timeoutType === 'variable') {
      tried = this._attempts - attemptsLeft - 1;
      return (this._timeout * tried) + _.random(50, this._timeout);
    } else {
      throw new Error("Unsupported timeout type: " + this._timeoutType);
    }
  };

  return Repeater;

})();

exports.Repeater = Repeater;
