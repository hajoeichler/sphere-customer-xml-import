/* ===========================================================
# sphere-node-connect - v0.5.6
# ==============================================================
# Copyright (c) 2013 Nicola Molinari
# Licensed under the MIT license.
*/
var Logger, OAuth2, Rest, request, _;

_ = require('underscore');

_.mixin(require('sphere-node-utils')._u);

request = require('request');

Logger = require('./logger');

OAuth2 = require('./oauth2');


/**
 * Creates a new Rest instance, used to connect to https://api.sphere.io
 * @class Rest
 */

Rest = (function() {

  /**
   * Initialize the class
   * @constructor
   * @param {Object} [opts] A JSON object containg configuration options
   * @throws {Error} if credentials are missing
   */
  function Rest(opts) {
    var config, oauth_options, rejectUnauthorized, userAgent;
    if (opts == null) {
      opts = {};
    }
    config = opts.config;
    if (!config) {
      throw new Error('Missing credentials');
    }
    if (!config.client_id) {
      throw new Error('Missing \'client_id\'');
    }
    if (!config.client_secret) {
      throw new Error('Missing \'client_secret\'');
    }
    if (!config.project_key) {
      throw new Error('Missing \'project_key\'');
    }
    this.logger = new Logger(opts.logConfig);
    rejectUnauthorized = _.isUndefined(opts.rejectUnauthorized) ? true : opts.rejectUnauthorized;
    userAgent = _.isUndefined(opts.user_agent) ? 'sphere-node-connect' : opts.user_agent;
    this._options = {
      config: config,
      host: opts.host || 'api.sphere.io',
      access_token: opts.access_token || void 0,
      timeout: opts.timeout || 20000,
      rejectUnauthorized: rejectUnauthorized,
      headers: {
        'User-Agent': userAgent
      }
    };
    this._options.uri = "https://" + this._options.host + "/" + this._options.config.project_key;
    oauth_options = _.clone(opts);
    _.extend(oauth_options, {
      host: opts.oauth_host
    });
    this._oauth = new OAuth2(oauth_options);
    if (this._options.access_token) {
      this._options.headers['Authorization'] = "Bearer " + this._options.access_token;
    }
    this.logger.debug(this._options, 'New Rest object');
    return;
  }


  /**
   * Send a HTTP GET request to an API endpoint
   * @param {String} resource The API resource endpoint, with query string parameters.
   * @param {Function} callback A function fulfilled with `error, response, body` arguments.
   */

  Rest.prototype.GET = function(resource, callback) {
    var params;
    params = {
      method: 'GET',
      resource: resource
    };
    this.logger.debug(_.extend({}, params, {
      project: this._options.config.project_key
    }));
    return this._preRequest(params, callback);
  };


  /**
   * Send a HTTP POST request to an API endpoint
   * @param {String} resource The API resource endpoint, with query string parameters.
   * @param {Object} payload A JSON object used as `body` payload
   * @param {Function} callback A function fulfilled with `error, response, body` arguments.
   */

  Rest.prototype.POST = function(resource, payload, callback) {
    var params;
    params = {
      method: 'POST',
      resource: resource,
      body: payload
    };
    this.logger.debug(_.extend({}, params, {
      project: this._options.config.project_key
    }));
    return this._preRequest(params, callback);
  };


  /**
   * Send a HTTP DELETE request to an API endpoint
   * @param {String} resource The API resource endpoint, with query string parameters.
   * @param {Function} callback A function fulfilled with `error, response, body` arguments.
   */

  Rest.prototype.DELETE = function(resource, callback) {
    var params;
    params = {
      method: 'DELETE',
      resource: resource
    };
    this.logger.debug(_.extend({}, params, {
      project: this._options.config.project_key
    }));
    return this._preRequest(params, callback);
  };


  /**
   * @throws {Error} as there is currently no implementation
   */

  Rest.prototype.PUT = function() {
    throw new Error('Not implemented yet');
  };


  /**
   * Prepare the request to be sent by automatically retrieving an `access_token`
   * @param {Object} params A JSON object containing all required parameters for the request
   * @param {Function} callback A function fulfilled with `error, response, body` arguments.
   * @throws {Error} if `access_token` could not be retrieved
   */

  Rest.prototype._preRequest = function(params, callback) {
    var _req;
    _req = (function(_this) {
      return function(retry) {
        var request_options;
        if (!_this._options.access_token) {
          return _this._oauth.getAccessToken(function(error, response, body) {
            var access_token;
            if (error) {
              if (retry === 10) {
                throw new Error('Error on retrieving access_token after 10 attempts.\n' + ("Error: " + error + "\n"));
              } else {
                _this.logger.debug("Failed to retrieve access_token, retrying..." + (retry + 1));
                return _req(retry + 1);
              }
            }
            if (response.statusCode !== 200) {
              if (retry === 10) {
                throw new Error('Could not retrieve access_token after 10 attempts.\n' + ("Status code: " + response.statusCode + "\n") + ("Body: " + body + "\n"));
              } else {
                _this.logger.debug("Failed to retrieve access_token, retrying..." + (retry + 1));
                return _req(retry + 1);
              }
            } else {
              access_token = body.access_token;
              _this._options.access_token = access_token;
              _this._options.headers['Authorization'] = "Bearer " + _this._options.access_token;
              _this.logger.debug('New access_token received', access_token);
              return _req(0);
            }
          });
        } else {
          request_options = {
            uri: "" + _this._options.uri + params.resource,
            json: true,
            method: params.method,
            headers: _this._options.headers,
            timeout: _this._options.timeout,
            rejectUnauthorized: _this._options.rejectUnauthorized
          };
          if (params.body) {
            request_options.body = params.body;
          }
          return _this._doRequest(request_options, callback);
        }
      };
    })(this);
    return _req(0);
  };


  /**
   * Execute the request using the underling `request` module
   * @link https://github.com/mikeal/request
   * @param {Object} options A JSON object containing all required options for the request
   * @param {Function} callback A function fulfilled with `error, response, body` arguments.
   */

  Rest.prototype._doRequest = function(options, callback) {
    return request(options, (function(_this) {
      return function(e, r, b) {
        if (e) {
          _this.logger.error(e);
        }
        _this.logger.debug({
          request: r != null ? r.request : void 0,
          response: r
        }, 'Rest response');
        return callback(e, r, b);
      };
    })(this));
  };


  /**
   * Fetch all results of a Sphere resource query endpoint in batches of pages using a recursive function.
   * Supports subscription of progress notifications.
   * @param {String} resource The resource endpoint to be queried, with query string parameters.
   * @param {Function} resolve A function fulfilled with `error, response, body` arguments. Body is an {Object} of {PagedQueryResponse}
   * @param {Function} [notify] A function fulfilled with `percentage, value` arguments. Value is an {Object} of the current body results.
   *                            This function is called for each batch iteration, allowing you to track the progress.
   * @throws {Error} if `limit` param is not 0
   */

  Rest.prototype.PAGED = function(resource, resolve, notify) {
    var endpoint, limit, params, query, splitted, tmpResponse, _buildPagedQueryResponse, _page;
    splitted = resource.split('?');
    endpoint = splitted[0];
    query = _.parseQuery(splitted[1]);
    if (query.limit && query.limit !== '0') {
      throw new Error('Query limit doesn\'t seem to be 0. This function queries all results, are you sure you want to use this?');
    }
    params = _.extend({}, query, {
      limit: 50,
      offset: 0
    });
    limit = params.limit;
    _buildPagedQueryResponse = function(results) {
      var tot;
      tot = _.size(results);
      return {
        offset: params.offset,
        count: tot,
        total: tot,
        results: results
      };
    };
    tmpResponse = {};
    _page = (function(_this) {
      return function(offset, total, accumulator) {
        var queryParams;
        if (accumulator == null) {
          accumulator = [];
        }
        if ((total != null) && (offset + limit) >= total + limit) {
          if (notify) {
            notify({
              percentage: 100,
              value: accumulator
            });
          }
          return resolve(null, tmpResponse, _buildPagedQueryResponse(accumulator));
        } else {
          queryParams = _.stringifyQuery(_.extend({}, params, {
            offset: offset
          }));
          return _this.GET("" + endpoint + "?" + queryParams, function(error, response, body) {
            if (notify) {
              notify({
                percentage: total ? _.percentage(offset, total) : 0,
                value: body
              });
            }
            if (error) {
              return resolve(error, response, body);
            } else {
              if (response.statusCode === 200) {
                tmpResponse = response;
                return _page(offset + limit, body.total, accumulator.concat(body.results));
              } else {
                return resolve(error, response, body);
              }
            }
          });
        }
      };
    })(this);
    _page(params.offset);
  };

  return Rest;

})();


/*
Exports object
 */

module.exports = Rest;
