var BaseService, Q, REGEX_LAST, Utils, _;

_ = require('underscore');

Q = require('q');

Utils = require('../utils');


/**
 * @const
 * RegExp to parse time period for last function.
 */

REGEX_LAST = /^(\d+)([s|m|h|d|w])$/;


/**
 * Creates a new BaseService, containing base functionalities. It should be extended when defining a Service.
 * @class BaseService
 */

BaseService = (function() {

  /**
   * @const
   * @private
   * Base path for a API resource endpoint (to be overriden by specific service)
   * @type {String}
   */
  BaseService.baseResourceEndpoint = '';


  /**
   * Initialize the class.
   * @constructor
   * @param {Rest} _rest An instance of the Rest client (sphere-node-connect)
   * @param {Logger} _logger An instance of a Logger (https://github.com/emmenko/sphere-node-connect#logging)
   */

  function BaseService(_rest, _logger, _task) {
    this._rest = _rest;
    this._logger = _logger;
    this._task = _task;
    this._setDefaults();
  }


  /**
   * @private
   * Reset default _currentEndpoint and _params used to build request endpoints
   */

  BaseService.prototype._setDefaults = function() {

    /**
     * @private
     * Current path for a API resource endpoint which can be modified by appending ids, queries, etc
     * @type {String}
     */
    this._currentEndpoint = this.constructor.baseResourceEndpoint;

    /**
     * @private
     * Container that holds request parameters such `id`, `query`, etc
     * @type {Object}
     */
    return this._params = {
      query: {
        where: [],
        operator: 'and',
        sort: [],
        expand: []
      }
    };
  };


  /**
   * Build the endpoint path by appending the given id
   * @param {String} id The resource specific id
   * @return {BaseService} Chained instance of this class
   */

  BaseService.prototype.byId = function(id) {
    this._currentEndpoint = "" + this.constructor.baseResourceEndpoint + "/" + id;
    this._params.id = id;
    this._logger.debug(this._currentEndpoint, 'Setting endpoint with ID');
    return this;
  };


  /**
   * Define a {Predicate} used for quering and filtering a resource.
   * @link http://commercetools.de/dev/http-api.html#predicates
   * @param {String} [predicate] A {Predicate} string for the `where` query parameter.
   * @return {BaseService} Chained instance of this class
   */

  BaseService.prototype.where = function(predicate) {
    var encodedPredicate;
    if (!predicate) {
      return this;
    }
    encodedPredicate = encodeURIComponent(predicate);
    this._params.query.where.push(encodedPredicate);
    this._logger.debug(this._params.query, 'Setting \'where\' parameter');
    return this;
  };


  /**
   * Define the logical operator to combine multiple `where` query parameters.
   * @param {String} [operator] A logical operator (default `and`)
   * @return {BaseService} Chained instance of this class
   */

  BaseService.prototype.whereOperator = function(operator) {
    if (operator == null) {
      operator = 'and';
    }
    this._params.query.operator = (function() {
      switch (operator) {
        case 'and':
        case 'or':
          return operator;
        default:
          return 'and';
      }
    })();
    this._logger.debug(this._params.query, 'Setting \'where\' operator');
    return this;
  };


  /**
   * This is a convenient method to query for the latest changes.
   * @param {String} period time period of format "numberX" where "X" is one of the follwing units:
   * s -> seconds
   * m -> minutes
   * h -> hours
   * d -> days
   * w -> weeks
   * @throws {Error} If period cannot be parsed
   * @return {BaseService} Chained instance of this class
   */

  BaseService.prototype.last = function(period) {
    var amount, before, dateTime, matches, now;
    if (!REGEX_LAST.test(period)) {
      throw new Error("Cannot parse period '" + period + "'");
    }
    matches = REGEX_LAST.exec(period);
    amount = matches[1];
    if (amount === '0') {
      return this;
    }
    before = Utils.getTime(amount, matches[2]);
    now = new Date().getTime();
    dateTime = new Date(now - before).toISOString();
    return this.where("lastModifiedAt > \"" + dateTime + "\"");
  };


  /**
   * Define how the query should be sorted.
   * It is possible to add several sort criteria, thereby the order is relevant.
   * @param {String} path Sort path to search for
   * @param {Boolean} [ascending] Whether the direction should be ascending or not, (default `asc`)
   *                              `true` = asc, `false` = desc
   * @return {BaseService} Chained instance of this class
   */

  BaseService.prototype.sort = function(path, ascending) {
    var direction;
    if (ascending == null) {
      ascending = true;
    }
    direction = ascending ? 'asc' : 'desc';
    this._params.query.sort.push(encodeURIComponent("" + path + " " + direction));
    this._logger.debug(this._params.query, 'Setting \'sort\' parameter');
    return this;
  };


  /**
   * Define the page number to be requested from the complete query result
   * (used for pagination as `offset`)
   * @param {Number} page A number >= 1 (default is 1)
   * @throws {Error} If argument is not a number >= 1
   * @return {BaseService} Chained instance of this class
   */

  BaseService.prototype.page = function(page) {
    if (_.isNumber(page) && page < 1) {
      throw new Error('Page must be a number >= 1');
    }
    this._params.query.page = page;
    this._logger.debug(this._params.query, 'Setting \'page\' parameter');
    return this;
  };


  /**
   * Define the number of results to return from a query
   * (used for pagination as `limit`)
   * @see _pagedFetch if limit is `0` (all results)
   * @param {Number} perPage A number >= 0 (default is 100)
   * @throws {Error} If argument is not a number >= 0
   * @return {BaseService} Chained instance of this class
   */

  BaseService.prototype.perPage = function(perPage) {
    if (_.isNumber(perPage) && perPage < 0) {
      throw new Error('PerPage (limit) must be a number >= 0');
    }
    this._params.query.perPage = perPage;
    this._logger.debug(this._params.query, 'Setting \'perPage\' parameter');
    return this;
  };


  /**
   * Alias for {@link perPage(0)}.
   */

  BaseService.prototype.all = function() {
    return this.perPage(0);
  };


  /**
   * Define an {ExpansionPath} used for expanding {Reference}s of a resource.
   * @link http://commercetools.de/dev/http-api.html#reference-expansion
   * @param {String} [expansionPath] An {ExpansionPath} string for the `expand` query parameter.
   * @return {BaseService} Chained instance of this class
   */

  BaseService.prototype.expand = function(expansionPath) {
    var encodedExpansionPath;
    if (!expansionPath) {
      return this;
    }
    encodedExpansionPath = encodeURIComponent(expansionPath);
    this._params.query.expand.push(encodedExpansionPath);
    this._logger.debug(this._params.query, 'Setting \'expand\' parameter');
    return this;
  };


  /**
   * @private
   * Build a query string from (pre)defined params
   * (to be overriden for custom params)
   * @return {String} the query string
   */

  BaseService.prototype._queryString = function() {
    var qs;
    qs = Utils.buildQueryString({
      where: this._params.query.where,
      whereOperator: this._params.query.operator,
      page: this._params.query.page,
      perPage: this._params.query.perPage,
      sort: this._params.query.sort
    });
    this._logger.debug(qs, 'Query string generated');
    return qs;
  };


  /**
   * Fetch resource defined by _currentEndpoint with query parameters
   * @return {Promise} A promise, fulfilled with an {Object} or rejected with a {SphereError}
   */

  BaseService.prototype.fetch = function() {
    var endpoint, queryString;
    queryString = this._queryString();
    endpoint = this._currentEndpoint;
    if (queryString) {
      endpoint += "?" + queryString;
    }
    if (this._params.query.perPage === 0) {
      return this._paged(endpoint);
    } else {
      return this._get(endpoint);
    }
  };


  /**
   * Process the resources for each page separatly using the function fn.
   * The function fn will then be called once for per page.
   * The function fn has to return a promise that should be resolved when all elements of the page are processed.
   * @param {Function} fn The function to process a page that returns a promise
   * @throws {Error} If argument is not a function
   * @return {Promise} A promise, fulfilled with an array of the resolved results of function fn or the rejected result of fn
   * @example
   *   page(3).perPage(5) will start processing at element 10, gives you a payload of 5 elements per call of fn again and again until all elements are processed.
   */

  BaseService.prototype.process = function(fn, options) {
    var deferred, endpoint, originalQuery, _processPage;
    if (options == null) {
      options = {};
    }
    if (!_.isFunction(fn)) {
      throw new Error('Please provide a function to process the elements');
    }
    options = _.defaults(options, {
      accumulate: true
    });
    deferred = Q.defer();
    endpoint = this.constructor.baseResourceEndpoint;
    originalQuery = this._params.query;
    _processPage = (function(_this) {
      return function(page, perPage, total, acc) {
        var queryString;
        if (acc == null) {
          acc = [];
        }
        _this._logger.debug({
          page: page,
          perPage: perPage,
          offset: (page - 1) * perPage,
          total: total
        }, 'Processing next page');
        if ((total != null) && (page - 1) * perPage >= total) {
          return deferred.resolve(acc);
        } else {
          _this._params.query = _.extend({}, originalQuery, {
            page: page,
            perPage: perPage
          });
          queryString = _this._queryString();
          return _this._get("" + endpoint + "?" + queryString).then(function(payload) {
            return fn(payload).then(function(result) {
              var accumulated, newTotal, nextPage;
              newTotal = payload.body.total;
              if (!total || total === newTotal) {
                nextPage = page + 1;
              } else if (total < newTotal) {
                nextPage = page;
                _this._logger.debug("Total is bigger then before, assuming something has been newly created. Processing the same page (" + nextPage + ").");
              } else {
                nextPage = page - 1;
                if (nextPage < 1) {
                  nextPage = 1;
                }
                _this._logger.debug("Total is lesser then before, assuming something has been deleted. Reducing page to " + nextPage + " (min 1).");
              }
              if (options.accumulate) {
                accumulated = acc.concat(result);
              }
              return _processPage(nextPage, perPage, newTotal, accumulated);
            });
          }).fail(function(error) {
            return deferred.reject(error);
          }).done();
        }
      };
    })(this);
    _processPage(this._params.query.page || 1, this._params.query.perPage || 20);
    return deferred.promise;
  };


  /**
   * Save a new resource by sending a payload to the _currentEndpoint, describing
   * the new resource model.
   * If the `id` was provided, the API expects the request to be an update by
   * by providing a payload of {UpdateAction}.
   * @param {Object} body The payload as JSON object
   * @throws {Error} If body is not given
   * @return {Promise} A promise, fulfilled with an {Object} or rejected with a {SphereError}
   */

  BaseService.prototype.save = function(body) {
    var endpoint;
    if (!body) {
      throw new Error("Body payload is required for creating a resource (endpoint: " + this._currentEndpoint + ")");
    }
    endpoint = this._currentEndpoint;
    return this._save(endpoint, body);
  };


  /**
   * Alias for {@link save}.
   */

  BaseService.prototype.create = function() {
    return this.save.apply(this, arguments);
  };


  /**
   * Alias for {@link save}, as it's the same type of HTTP request.
   * Updating a resource is done by sending a list of {UpdateAction}.
   * (more intuitive way of describing an update, given that an [id] is provided)
   * @example `{service}.byId({id}).update({actions})`
   */

  BaseService.prototype.update = function() {
    return this.save.apply(this, arguments);
  };


  /**
   * Delete an existing resource of the _currentEndpoint
   * If the `id` was provided, the API expects this to be a resource update with given {UpdateAction}
   * @param {Number} version The current version of the resource
   * @throws {Error} If version is not given
   * @return {Promise} A promise, fulfilled with an {Object} or rejected with a {SphereError}
   */

  BaseService.prototype["delete"] = function(version) {
    var endpoint;
    if (!version) {
      throw new Error("Version is required for deleting a resource (endpoint: " + this._currentEndpoint + ")");
    }
    endpoint = "" + this._currentEndpoint + "?version=" + version;
    return this._delete(endpoint);
  };


  /**
   * Return a {Promise} for a GET call. It can be overridden for custom logic.
   * @param {String} endpoint The resource endpoint
   * @return {Promise} A promise, fulfilled with an {Object} or rejected with a {SphereError}
   */

  BaseService.prototype._get = function(endpoint) {
    return this._task.addTask((function(_this) {
      return function() {
        var deferred, originalRequest;
        _this._setDefaults();
        originalRequest = {
          endpoint: endpoint
        };
        deferred = Q.defer();
        _this._rest.GET(endpoint, function() {
          return _this._wrapResponse.apply(_this, [deferred, originalRequest].concat(_.toArray(arguments)));
        });
        return deferred.promise;
      };
    })(this));
  };


  /**
   * Return a {Promise} for a PAGED call. It can be overridden for custom logic.
   * @param {String} endpoint The resource endpoint
   * @return {Promise} A promise, fulfilled with an {Object} or rejected with a {SphereError}
   */

  BaseService.prototype._paged = function(endpoint) {
    return this._task.addTask((function(_this) {
      return function() {
        var deferred, originalRequest;
        _this._setDefaults();
        originalRequest = {
          endpoint: endpoint
        };
        deferred = Q.defer();
        _this._rest.PAGED(endpoint, function() {
          return _this._wrapResponse.apply(_this, [deferred, originalRequest].concat(_.toArray(arguments)));
        }, function(progress) {
          return deferred.notify(progress);
        });
        return deferred.promise;
      };
    })(this));
  };


  /**
   * Return a {Promise} for a POST call. It can be overridden for custom logic.
   * @param {String} endpoint The resource endpoint
   * @param {String} payload The body payload as a String
   * @return {Promise} A promise, fulfilled with an {Object} or rejected with a {SphereError}
   */

  BaseService.prototype._save = function(endpoint, payload) {
    return this._task.addTask((function(_this) {
      return function() {
        var deferred, originalRequest;
        _this._setDefaults();
        originalRequest = {
          endpoint: endpoint,
          payload: payload
        };
        deferred = Q.defer();
        _this._rest.POST(endpoint, payload, function() {
          return _this._wrapResponse.apply(_this, [deferred, originalRequest].concat(_.toArray(arguments)));
        });
        return deferred.promise;
      };
    })(this));
  };


  /**
   * Return a {Promise} for a DELETE call. It can be overridden for custom logic.
   * @param {String} endpoint The resource endpoint
   * @return {Promise} A promise, fulfilled with an {Object} or rejected with a {SphereError}
   */

  BaseService.prototype._delete = function(endpoint) {
    return this._task.addTask((function(_this) {
      return function() {
        var deferred, originalRequest;
        _this._setDefaults();
        originalRequest = {
          endpoint: endpoint
        };
        deferred = Q.defer();
        _this._rest.DELETE(endpoint, function() {
          return _this._wrapResponse.apply(_this, [deferred, originalRequest].concat(_.toArray(arguments)));
        });
        return deferred.promise;
      };
    })(this));
  };


  /**
   * @private
   * Wrap responses and decide whether to reject or resolve the promise
   * @param {Promise} deferred The deferred promise
   * @param {Object} error An error object when applicable (usually from `http.ClientRequest` object) otherwise `null`
   * @param {Object} response An `http.IncomingMessage` object containing all kind of information about the request / response
   * @param {Object} body A JSON object containing the HTTP API resource or error messages
   */

  BaseService.prototype._wrapResponse = function(deferred, originalRequest, error, response, body) {
    var endpoint, _ref;
    if (error) {
      return deferred.reject({
        statusCode: 500,
        message: error,
        originalRequest: originalRequest
      });
    } else {
      if ((200 <= (_ref = response.statusCode) && _ref < 300)) {
        return deferred.resolve({
          statusCode: response.statusCode,
          body: body
        });
      } else if (response.statusCode === 404) {
        endpoint = response.request.uri.path;
        return deferred.reject({
          statusCode: 404,
          message: "Endpoint '" + endpoint + "' not found.",
          originalRequest: originalRequest
        });
      } else {
        return deferred.reject(_.extend(body, {
          originalRequest: originalRequest
        }));
      }
    }
  };

  return BaseService;

})();


/**
 * The {@link BaseService} service.
 */

module.exports = BaseService;
